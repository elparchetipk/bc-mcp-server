name: ğŸ³ Docker Build & Validation

# Este workflow valida que las imÃ¡genes de Docker se construyan correctamente
# y que los servicios funcionen como se espera
on:
  push:
    branches: [main, develop]
    paths:
      - 'docker-compose.yml'
      - 'herramientas/docker/**'
      - '.dockerignore'
      - 'Dockerfile*'
  pull_request:
    paths:
      - 'docker-compose.yml'
      - 'herramientas/docker/**'
      - '.dockerignore'
      - 'Dockerfile*'
  schedule:
    # Ejecutar semanalmente para verificar actualizaciones de imÃ¡genes base
    - cron: '0 6 * * 1'

# Permisos necesarios
permissions:
  contents: read
  packages: write

jobs:
  # 1. Validar archivos Docker
  validate-docker:
    name: ğŸ” Validar ConfiguraciÃ³n Docker
    runs-on: ubuntu-latest

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ” Validar docker-compose.yml
        run: |
          echo "Validando sintaxis de docker-compose.yml..."
          docker compose config --quiet

          echo "âœ… docker-compose.yml es vÃ¡lido"

      - name: ğŸ” Validar estructura de directorios
        run: |
          echo "Validando estructura de Docker..."

          # Verificar que existen las carpetas esperadas
          [ -d "herramientas/docker" ] || { echo "âŒ Falta directorio herramientas/docker"; exit 1; }

          echo "âœ… Estructura de directorios correcta"

      - name: ğŸ“‹ Listar configuraciÃ³n de servicios
        run: |
          echo "## ğŸ“‹ ConfiguraciÃ³n de Servicios"
          docker compose config --services

          echo ""
          echo "## ğŸ”§ Variables de entorno requeridas"
          grep -E "^\s*[A-Z_]+=\$\{" docker-compose.yml | sed 's/.*\${\([^}]*\)}.*/\1/' | sort -u

  # 2. Build de imÃ¡genes
  build-images:
    name: ğŸ—ï¸ Build de ImÃ¡genes
    runs-on: ubuntu-latest
    needs: validate-docker

    strategy:
      matrix:
        service: [bootcamp-dev, db]

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ³ Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ“‹ Crear archivo .env para testing
        run: |
          cp .env.example .env
          echo "NODE_ENV=test" >> .env

      - name: ğŸ—ï¸ Build imagen de ${{ matrix.service }}
        run: |
          echo "Construyendo imagen para servicio: ${{ matrix.service }}"
          docker compose build ${{ matrix.service }}

      - name: ğŸ“Š Analizar tamaÃ±o de imagen
        run: |
          IMAGE_ID=$(docker compose images -q ${{ matrix.service }})
          if [ ! -z "$IMAGE_ID" ]; then
            echo "## ğŸ“Š InformaciÃ³n de la imagen ${{ matrix.service }}"
            docker images $IMAGE_ID --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"
            
            # Mostrar capas para anÃ¡lisis de optimizaciÃ³n
            echo ""
            echo "## ğŸ“‹ Historial de capas (Ãºltimas 10)"
            docker history $IMAGE_ID --format "table {{.CreatedBy}}\t{{.Size}}" | head -11
          fi

  # 3. Test de servicios
  test-services:
    name: ğŸ§ª Test de Servicios
    runs-on: ubuntu-latest
    needs: build-images

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ“‹ Preparar entorno de testing
        run: |
          cp .env.example .env

          # Configurar credenciales de testing
          sed -i 's/bootcamp_user/test_user/g' .env
          sed -i 's/supersecretpassword/test_password/g' .env
          sed -i 's/mcp_bootcamp_db/test_db/g' .env

      - name: ğŸš€ Iniciar servicios
        run: |
          echo "Iniciando servicios..."
          docker compose up -d

          echo "Esperando que los servicios estÃ©n listos..."
          sleep 30

      - name: ğŸ” Verificar estado de servicios
        run: |
          echo "## ğŸ“Š Estado de los servicios"
          docker compose ps

          echo ""
          echo "## ğŸ“‹ Logs de servicios"
          docker compose logs --tail=20

      - name: ğŸ§ª Test de conectividad de base de datos
        run: |
          echo "Probando conexiÃ³n a PostgreSQL..."

          # Esperar hasta que PostgreSQL estÃ© listo
          timeout 60 bash -c 'until docker compose exec -T db pg_isready -U test_user; do sleep 2; done'

          echo "âœ… PostgreSQL estÃ¡ listo"

          # Probar consulta bÃ¡sica
          docker compose exec -T db psql -U test_user -d test_db -c "SELECT version();"

          echo "âœ… Consulta bÃ¡sica exitosa"

      - name: ğŸ§ª Test del entorno de desarrollo
        run: |
          echo "Probando entorno de desarrollo..."

          # Verificar que Node.js estÃ¡ disponible
          NODE_VERSION=$(docker compose exec -T bootcamp-dev node --version)
          echo "Node.js version: $NODE_VERSION"

          # Verificar que pnpm estÃ¡ disponible
          PNPM_VERSION=$(docker compose exec -T bootcamp-dev pnpm --version 2>/dev/null || echo "pnpm no instalado")
          echo "pnpm version: $PNPM_VERSION"

          # Instalar pnpm si no estÃ¡ disponible
          if [[ "$PNPM_VERSION" == "pnpm no instalado" ]]; then
            echo "Instalando pnpm..."
            docker compose exec -T bootcamp-dev npm install -g pnpm
            PNPM_VERSION=$(docker compose exec -T bootcamp-dev pnpm --version)
            echo "pnpm instalado: $PNPM_VERSION"
          fi

          echo "âœ… Entorno de desarrollo funcional"

      - name: ğŸ§ª Test de volÃºmenes persistentes
        run: |
          echo "Probando persistencia de datos..."

          # Crear un archivo de prueba en el volumen de datos
          docker compose exec -T db touch /var/lib/postgresql/data/test-file

          # Reiniciar servicio de BD
          docker compose restart db
          sleep 10

          # Verificar que el archivo persiste
          if docker compose exec -T db ls /var/lib/postgresql/data/test-file > /dev/null 2>&1; then
            echo "âœ… Volumen de datos persiste correctamente"
          else
            echo "âŒ Problema con persistencia de volumen"
            exit 1
          fi

      - name: ğŸ” Test de logs y monitoreo
        run: |
          echo "Verificando logs de servicios..."

          # Verificar que no hay errores crÃ­ticos en los logs
          if docker compose logs | grep -i "error\|fatal\|exception" | grep -v "INFO\|WARN"; then
            echo "âš ï¸  Se encontraron errores en los logs:"
            docker compose logs | grep -i "error\|fatal\|exception" | grep -v "INFO\|WARN"
          else
            echo "âœ… No se encontraron errores crÃ­ticos en los logs"
          fi

      - name: ğŸ§¹ Cleanup y verificaciÃ³n final
        run: |
          echo "Realizando cleanup..."

          # Detener servicios
          docker compose down

          echo "âœ… Servicios detenidos correctamente"

        if: always()

  # 4. Security scan de imÃ¡genes
  security-scan:
    name: ğŸ”’ Security Scan
    runs-on: ubuntu-latest
    needs: build-images
    if: github.event_name != 'schedule'

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ“‹ Preparar entorno
        run: |
          cp .env.example .env

      - name: ğŸ—ï¸ Build imÃ¡genes para scanning
        run: |
          docker compose build

      - name: ğŸ”’ Scan de seguridad con Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'node:18-alpine'
          format: 'sarif'
          output: 'trivy-node-results.sarif'

      - name: ğŸ”’ Scan de PostgreSQL
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'postgres:15-alpine'
          format: 'sarif'
          output: 'trivy-postgres-results.sarif'

      - name: ğŸ“¤ Subir resultados de seguridad
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-node-results.sarif'

      - name: ğŸ“¤ Subir resultados PostgreSQL
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-postgres-results.sarif'

  # 5. Performance benchmarks
  performance:
    name: âš¡ Performance Tests
    runs-on: ubuntu-latest
    needs: test-services
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ“‹ Preparar entorno
        run: |
          cp .env.example .env

      - name: ğŸš€ Iniciar servicios para benchmark
        run: |
          docker compose up -d
          sleep 30

      - name: âš¡ Benchmark de base de datos
        run: |
          echo "Ejecutando benchmark de PostgreSQL..."

          # Benchmark bÃ¡sico de conexiones
          time docker compose exec -T db psql -U test_user -d test_db -c "SELECT 1;" > /dev/null

          # Benchmark de inserciÃ³n
          START_TIME=$(date +%s%N)
          for i in {1..100}; do
            docker compose exec -T db psql -U test_user -d test_db -c "SELECT pg_sleep(0.001);" > /dev/null
          done
          END_TIME=$(date +%s%N)

          DURATION=$(( (END_TIME - START_TIME) / 1000000 ))
          echo "100 consultas simples: ${DURATION}ms"

      - name: âš¡ Benchmark del entorno de desarrollo
        run: |
          echo "Ejecutando benchmark del entorno Node.js..."

          # Tiempo de inicio de Node.js
          START_TIME=$(date +%s%N)
          docker compose exec -T bootcamp-dev node -e "console.log('Hello World')" > /dev/null
          END_TIME=$(date +%s%N)

          DURATION=$(( (END_TIME - START_TIME) / 1000000 ))
          echo "Tiempo de inicio de Node.js: ${DURATION}ms"

      - name: ğŸ“Š Guardar mÃ©tricas
        run: |
          echo "## âš¡ MÃ©tricas de Performance" > performance-metrics.md
          echo "- Fecha: $(date)" >> performance-metrics.md
          echo "- Commit: ${{ github.sha }}" >> performance-metrics.md
          echo "- Rama: ${{ github.ref_name }}" >> performance-metrics.md

      - name: ğŸ“¤ Subir mÃ©tricas
        uses: actions/upload-artifact@v3
        with:
          name: performance-metrics
          path: performance-metrics.md

      - name: ğŸ§¹ Cleanup
        run: docker compose down
        if: always()

  # 6. Resumen final
  summary:
    name: ğŸ“Š Resumen de Docker Validation
    runs-on: ubuntu-latest
    needs:
      [validate-docker, build-images, test-services, security-scan, performance]
    if: always()

    steps:
      - name: ğŸ“Š Generar resumen
        run: |
          echo "## ğŸ³ Resumen de ValidaciÃ³n Docker"
          echo ""
          echo "| Check | Estado |"
          echo "|-------|--------|"
          echo "| ValidaciÃ³n de configuraciÃ³n | ${{ needs.validate-docker.result == 'success' && 'âœ…' || 'âŒ' }} |"
          echo "| Build de imÃ¡genes | ${{ needs.build-images.result == 'success' && 'âœ…' || 'âŒ' }} |"
          echo "| Test de servicios | ${{ needs.test-services.result == 'success' && 'âœ…' || 'âŒ' }} |"
          echo "| Security scan | ${{ needs.security-scan.result == 'success' && 'âœ…' || needs.security-scan.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |"
          echo "| Performance tests | ${{ needs.performance.result == 'success' && 'âœ…' || needs.performance.result == 'skipped' && 'â­ï¸' || 'âŒ' }} |"

          if [[ "${{ needs.validate-docker.result }}" == "success" && "${{ needs.build-images.result }}" == "success" && "${{ needs.test-services.result }}" == "success" ]]; then
            echo ""
            echo "ğŸ‰ Â¡Todas las validaciones de Docker pasaron correctamente!"
          else
            echo ""
            echo "âŒ Algunas validaciones fallaron. Revisa los logs arriba."
            exit 1
          fi
